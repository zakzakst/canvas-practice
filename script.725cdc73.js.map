{"version":3,"sources":["script.js"],"names":["CardItems","_classCallCheck","containerScrollEl","document","querySelector","containerYEl","containerXEl","itemsEl","onScrollCallback","onScroll","bind","targetPosition","currentPosition","easingPosition","isMoving","easingTime","easingStart","_createClass","key","value","initObserver","addEventListener","options","root","rootMargin","threshold","window","innerHeight","clientHeight","IntersectionObserver","scrollEventObserve","observe","entries","_this","forEach","entry","isIntersecting","addScrollEvent","removeScrollEvent","removeEventListener","scrollProgress","getScrollProgress","getTargetPosition","style","transform","concat","elapsedTime","Date","now","t","b","c","d","position","console","log","requestAnimationFrame","moveToTargetPosition","containerScrollRect","getBoundingClientRect","containerScrollTop","scrollY","top","scrollRange","progress","arrangedProgress","containerWidth","clientWidth","body","scrollWidth","cardItems","init"],"mappings":"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","file":"script.725cdc73.js","sourceRoot":"..\\src\\scroll_fix","sourcesContent":["class CardItems {\r\n  constructor() {\r\n    // 要素\r\n    this.containerScrollEl = document.querySelector(\r\n      \"#card-anim #container-scroll\"\r\n    );\r\n    this.containerYEl = document.querySelector(\"#card-anim #container-y\");\r\n    this.containerXEl = document.querySelector(\"#card-anim #container-x\");\r\n    this.itemsEl = document.querySelector(\"#card-anim #items\");\r\n    // スクロール関数（removeEventListenerする目的）\r\n    // https://log.tkyisgk.com/addeventlistener-this\r\n    this.onScrollCallback = this.onScroll.bind(this);\r\n    // 目標位置\r\n    this.targetPosition = 0;\r\n    // 現在の位置\r\n    this.currentPosition = 0;\r\n    // イージング中の位置\r\n    this.easingPosition = 0;\r\n    // 移動中かどうか\r\n    this.isMoving = false;\r\n    // イージングする時間（ms）\r\n    this.easingTime = 200;\r\n    // イージングの開始時間\r\n    this.easingStart = null;\r\n  }\r\n\r\n  /**\r\n   * 初期化\r\n   */\r\n  init() {\r\n    this.initObserver();\r\n    // リサイズ処理と再読み込みなどでページ途中で初期表示された場合の考慮\r\n    document.addEventListener(\"resize\", this.onScrollCallback);\r\n    this.onScroll();\r\n  }\r\n\r\n  /**\r\n   * インターセクションオブザーバー初期化\r\n   */\r\n  initObserver() {\r\n    // スクロール範囲がwindowを覆ったタイミングでスクロールイベントの出し分けを行う\r\n    const threshold = window.innerHeight / this.containerScrollEl.clientHeight;\r\n    const options = {\r\n      root: null,\r\n      rootMargin: \"0px\",\r\n      threshold,\r\n    };\r\n    const observer = new IntersectionObserver(\r\n      this.scrollEventObserve.bind(this),\r\n      options\r\n    );\r\n    observer.observe(this.containerScrollEl);\r\n  }\r\n\r\n  /**\r\n   * スクロールイベント監視\r\n   */\r\n  scrollEventObserve(entries) {\r\n    entries.forEach((entry) => {\r\n      if (entry.isIntersecting) {\r\n        this.addScrollEvent();\r\n      } else {\r\n        this.removeScrollEvent();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * スクロール処理追加\r\n   */\r\n  addScrollEvent() {\r\n    document.addEventListener(\"scroll\", this.onScrollCallback);\r\n  }\r\n\r\n  /**\r\n   * スクロール処理削除\r\n   */\r\n  removeScrollEvent() {\r\n    document.removeEventListener(\"scroll\", this.onScrollCallback);\r\n  }\r\n\r\n  /**\r\n   * スクロール処理\r\n   */\r\n  onScroll() {\r\n    const scrollProgress = this.getScrollProgress();\r\n    // 目標位置とイージング開始時間を更新し、移動中でなければ移動処理を発火\r\n    this.targetPosition = this.getTargetPosition(scrollProgress);\r\n    this.itemsEl.style.transform = `translateX(${this.targetPosition}px)`;\r\n    // TODO: イージング上手くいかない、イージングなしでもいい感じの動きな気がするから一旦これで対応\r\n    // // TODO: requestAnimationFrameの引数でtimestamp渡せるっぽい。こっちでやった方がスマートか？\r\n    // // https://coding-memo.work/javascript/895/\r\n    // this.easingStart = Date.now();\r\n    // if (!this.isMoving) {\r\n    //   this.moveToTargetPosition();\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * 目標位置へ移動\r\n   */\r\n  moveToTargetPosition() {\r\n    // 経過時間\r\n    const elapsedTime = Date.now() - this.easingStart;\r\n    if (elapsedTime > this.easingTime) {\r\n      this.currentPosition = this.easingPosition;\r\n      return;\r\n    }\r\n    // イージング量を返す関数（「t：アニメーションの経過時間」「b：始点」「c：変化量」「d：変化にかける時間」）\r\n    // https://noze.space/archives/432\r\n    const easing = (t, b, c, d) => {\r\n      return c * (t /= d) * t + b;\r\n    };\r\n    // 移動位置\r\n    const position = easing(\r\n      elapsedTime,\r\n      this.currentPosition,\r\n      this.targetPosition,\r\n      this.easingTime\r\n    );\r\n    console.log(position);\r\n    this.easingPosition = position;\r\n    this.itemsEl.style.transform = `translateX(${position}px)`;\r\n    requestAnimationFrame(this.moveToTargetPosition.bind(this));\r\n  }\r\n\r\n  /**\r\n   * スクロール進行の割合の取得\r\n   * @returns スクロール進行の割合\r\n   */\r\n  getScrollProgress() {\r\n    // スクロール範囲の上下\r\n    const containerScrollRect = this.containerScrollEl.getBoundingClientRect();\r\n    const containerScrollTop = window.scrollY + containerScrollRect.top;\r\n    const containerScrollBottom =\r\n      containerScrollTop + this.containerScrollEl.clientHeight;\r\n    // Yコンテナの高さ\r\n    const containerYHeight = this.containerYEl.clientHeight;\r\n    // スクロール範囲\r\n    const scrollRange = {\r\n      start: containerScrollTop,\r\n      end: containerScrollBottom - containerYHeight,\r\n    };\r\n    // 現在のスクロール位置\r\n    const scrollCurrent = window.scrollY;\r\n    // スクロール進行の割合\r\n    const scrollProgress =\r\n      (scrollCurrent - scrollRange.start) /\r\n      (scrollRange.end - scrollRange.start);\r\n    return scrollProgress;\r\n  }\r\n\r\n  /**\r\n   * 目標位置の取得\r\n   * @param progress 進行割合\r\n   * @returns 目標位置\r\n   */\r\n  getTargetPosition(progress) {\r\n    const arrangedProgress = progress > 1 ? 1 : progress < 0 ? 0 : progress;\r\n    // NOTE: overflowの関係か幅取得上手くいかない（SP表示の時に）そのための対応\r\n    const containerWidth =\r\n      this.containerXEl.clientWidth >= document.body.clientWidth\r\n        ? document.body.clientWidth\r\n        : this.containerXEl.clientWidth;\r\n    const itemsWidth = this.itemsEl.scrollWidth;\r\n    const position = -(itemsWidth - containerWidth) * arrangedProgress;\r\n    return position;\r\n  }\r\n}\r\n\r\nconst cardItems = new CardItems();\r\ncardItems.init();\r\n"]}